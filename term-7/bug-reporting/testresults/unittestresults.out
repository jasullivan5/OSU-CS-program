Result for running tests:
cardtest1.c:
TESTING ADVENTURER CARD

Player 1's hand set to a single test card
Cards in played pile before playing test card: 0, expected: 0
Cards in played pile after playing test card: 0, expected: 1

TEST FAILED: Wrong played count
Enter to continue / 'E' to exit.

Cards in played pile:
Cards expected in played pile: adventurer

TEST FAILED: Wrong cards
Enter to continue / 'E' to exit.

Cards in deck before playing test card: 5
Cards in deck after playing test card: 2, expected: 3

TEST FAILED: Wrong deck count
Enter to continue / 'E' to exit.

Cards in hand before playing test card: 1
Cards in hand after playing test card: 3, expected: 2

TEST FAILED: Wrong hand count
Enter to continue / 'E' to exit.

Cards in discard before playing test card: 0
Cards in discard after playing test card: 0, expected: 1

TEST FAILED: wrong discard count
Enter to continue / 'E' to exit.

Making sure hand has only coins:
adventurer

TEST FAILED: cards other than coins drawn
Enter to continue / 'E' to exit.

copper
copper
Making sure only non-coins were discarded:
Making sure all other game states are unchanged
Player 2's hand set to a single test card
Cards in played pile before playing test card: 0, expected: 0
Cards in played pile after playing test card: 0, expected: 1

TEST FAILED: Wrong played count
Enter to continue / 'E' to exit.

Cards in played pile:
Cards expected in played pile: adventurer

TEST FAILED: Wrong cards
Enter to continue / 'E' to exit.

Cards in deck before playing test card: 10
Cards in deck after playing test card: 8, expected: 8
Cards in hand before playing test card: 1
Cards in hand after playing test card: 3, expected: 2

TEST FAILED: Wrong hand count
Enter to continue / 'E' to exit.

Cards in discard before playing test card: 0
Cards in discard after playing test card: 0, expected: 0
Making sure hand has only coins:
adventurer

TEST FAILED: cards other than coins drawn
Enter to continue / 'E' to exit.

copper
copper
Making sure only non-coins were discarded:
Making sure all other game states are unchanged
ONE OR MORE TESTS FAILED
Function 'updateCoins'
Lines executed:81.82% of 11

Function 'gainCard'
Lines executed:0.00% of 13

Function 'discardCard'
Lines executed:0.00% of 13

Function 'cardEffect'
Lines executed:5.34% of 206

Function 'getCost'
Lines executed:0.00% of 30

Function 'drawCard'
Lines executed:36.36% of 22

Function 'getWinners'
Lines executed:0.00% of 24

Function 'scoreFor'
Lines executed:0.00% of 42

Function 'isGameOver'
Lines executed:0.00% of 10

Function 'endTurn'
Lines executed:0.00% of 20

Function 'whoseTurn'
Lines executed:100.00% of 2

Function 'fullDeckCount'
Lines executed:0.00% of 12

Function 'supplyCount'
Lines executed:0.00% of 2

Function 'handCard'
Lines executed:0.00% of 3

Function 'numHandCards'
Lines executed:0.00% of 2

Function 'buyCard'
Lines executed:0.00% of 13

Function 'playCard'
Lines executed:0.00% of 14

Function 'shuffle'
Lines executed:93.75% of 16

Function 'initializeGame'
Lines executed:80.65% of 62

Function 'kingdomCards'
Lines executed:0.00% of 13

Function 'newGame'
Lines executed:0.00% of 3

Function 'compare'
Lines executed:83.33% of 6

Function 'treasure_map_card'
Lines executed:0.00% of 13

Function 'salvager_card'
Lines executed:0.00% of 7

Function 'village_card'
Lines executed:0.00% of 5

Function 'smithy_card'
Lines executed:0.00% of 5

Function 'adventurer_card'
Lines executed:80.00% of 15

Function 'printf'
Lines executed:0.00% of 5

File 'dominion.c'
Lines executed:19.18% of 584
Creating 'dominion.c.gcov'

File 'c:/mingw/include/stdio.h'
Lines executed:0.00% of 5
Creating 'stdio.h.gcov'

cardtest2.c:
TESTING GREAT HALL CARD

Player 1's hand set to a single copy of test card
Cards in played pile before playing test card 0
Cards in played pile after playing test card: 1
Cards in played pile:
great_hall
Player 1 cards in deck before playing test card: 5
Player 1 cards in deck after playing test card: 4
Player 1 cards in hand before playing test card: 1
Player 1 cards in hand after playing test card: 1
Top card of deck before playing test card:
estate
Cards in hand after playing test card:
estate
Actions before playing test card: 1
 Actions after playing test card: 2
Checking that other game states have remained the same.
Player 2's hand set to a single copy of test card
Cards in played pile before playing test card 0
Cards in played pile after playing test card: 1
Cards in played pile:
great_hall
Player 2 cards in deck before playing test card: 10
Player 2 cards in deck after playing test card: 9
Player 2 cards in hand before playing test card: 1
Player 2 cards in hand after playing test card: 1
Top card of deck before playing test card:
copper
Cards in hand after playing test card:
copper
Actions before playing test card: 1
 Actions after playing test card: 2
Checking that other game states have remained the same.
ALL TESTS PASSED
Function 'updateCoins'
Lines executed:81.82% of 11

Function 'gainCard'
Lines executed:0.00% of 13

Function 'discardCard'
Lines executed:84.62% of 13

Function 'cardEffect'
Lines executed:7.28% of 206

Function 'getCost'
Lines executed:0.00% of 30

Function 'drawCard'
Lines executed:36.36% of 22

Function 'getWinners'
Lines executed:0.00% of 24

Function 'scoreFor'
Lines executed:0.00% of 42

Function 'isGameOver'
Lines executed:0.00% of 10

Function 'endTurn'
Lines executed:0.00% of 20

Function 'whoseTurn'
Lines executed:100.00% of 2

Function 'fullDeckCount'
Lines executed:0.00% of 12

Function 'supplyCount'
Lines executed:0.00% of 2

Function 'handCard'
Lines executed:0.00% of 3

Function 'numHandCards'
Lines executed:0.00% of 2

Function 'buyCard'
Lines executed:0.00% of 13

Function 'playCard'
Lines executed:0.00% of 14

Function 'shuffle'
Lines executed:93.75% of 16

Function 'initializeGame'
Lines executed:80.65% of 62

Function 'kingdomCards'
Lines executed:0.00% of 13

Function 'newGame'
Lines executed:0.00% of 3

Function 'compare'
Lines executed:83.33% of 6

Function 'treasure_map_card'
Lines executed:0.00% of 13

Function 'salvager_card'
Lines executed:0.00% of 7

Function 'village_card'
Lines executed:0.00% of 5

Function 'smithy_card'
Lines executed:0.00% of 5

Function 'adventurer_card'
Lines executed:80.00% of 15

Function 'printf'
Lines executed:0.00% of 5

File 'dominion.c'
Lines executed:21.75% of 584
Creating 'dominion.c.gcov'

File 'c:/mingw/include/stdio.h'
Lines executed:0.00% of 5
Creating 'stdio.h.gcov'

cardtest3.c:
TESTING SMITHY CARD

Player 1's hand set to a single copy of test card
Cards in played pile before playing test card 0
Cards in played pile after playing test card: 0

TEST FAILED: Wrong number of cards in played pile
Enter to continue / 'E' to exit.

Cards in played pile:

TEST FAILED: Cards in played pile don't match
Enter to continue / 'E' to exit.

Player 1 cards in deck before playing test card: 5
Player 1 cards in deck after playing test ard: 2
Player 1 cards in hand before playing test card: 1
Player 1 cards in hand after playing test card: 3
Top 3 cards of deck before playing test card:
estate
copper
copper
Cards in hand after playing test card:
copper
estate
copper
Checking that other game states have remained the same.
Player 2's hand set to a single copy of test card
Cards in played pile before playing test card 0
Cards in played pile after playing test card: 0

TEST FAILED: Wrong number of cards in played pile
Enter to continue / 'E' to exit.

Cards in played pile:

TEST FAILED: Cards in played pile don't match
Enter to continue / 'E' to exit.

Player 2 cards in deck before playing test card: 10
Player 2 cards in deck after playing test ard: 7
Player 2 cards in hand before playing test card: 1
Player 2 cards in hand after playing test card: 3
Top 3 cards of deck before playing test card:
copper
copper
copper
Cards in hand after playing test card:
copper
copper
copper
Checking that other game states have remained the same.
ONE OR MORE TESTS FAILED
Function 'updateCoins'
Lines executed:81.82% of 11

Function 'gainCard'
Lines executed:0.00% of 13

Function 'discardCard'
Lines executed:84.62% of 13

Function 'cardEffect'
Lines executed:8.25% of 206

Function 'getCost'
Lines executed:0.00% of 30

Function 'drawCard'
Lines executed:36.36% of 22

Function 'getWinners'
Lines executed:0.00% of 24

Function 'scoreFor'
Lines executed:0.00% of 42

Function 'isGameOver'
Lines executed:0.00% of 10

Function 'endTurn'
Lines executed:0.00% of 20

Function 'whoseTurn'
Lines executed:100.00% of 2

Function 'fullDeckCount'
Lines executed:0.00% of 12

Function 'supplyCount'
Lines executed:0.00% of 2

Function 'handCard'
Lines executed:0.00% of 3

Function 'numHandCards'
Lines executed:0.00% of 2

Function 'buyCard'
Lines executed:0.00% of 13

Function 'playCard'
Lines executed:0.00% of 14

Function 'shuffle'
Lines executed:93.75% of 16

Function 'initializeGame'
Lines executed:80.65% of 62

Function 'kingdomCards'
Lines executed:0.00% of 13

Function 'newGame'
Lines executed:0.00% of 3

Function 'compare'
Lines executed:83.33% of 6

Function 'treasure_map_card'
Lines executed:0.00% of 13

Function 'salvager_card'
Lines executed:0.00% of 7

Function 'village_card'
Lines executed:0.00% of 5

Function 'smithy_card'
Lines executed:100.00% of 5

Function 'adventurer_card'
Lines executed:80.00% of 15

Function 'printf'
Lines executed:0.00% of 5

File 'dominion.c'
Lines executed:22.95% of 584
Creating 'dominion.c.gcov'

File 'c:/mingw/include/stdio.h'
Lines executed:0.00% of 5
Creating 'stdio.h.gcov'

cardtest4.c:
TESTING VILLAGE CARD

Player 1's hand set to a single copy of test card
Cards in played pile before playing test card 0
Cards in played pile after playing test card: 1
Cards in played pile:
village
Player 1 cards in deck before playing test card: 5
Player 1 cards in deck after playing test ard: 4
Player 1 cards in hand before playing test card: 1
Player 1 cards in hand after playing test card: 1
Top card of deck before playing test card:
estate
Cards in hand after playing test card:
estate
Actions before playing test card: 1
 Actions after playing test card: 2

TEST FAILED: Wrong action count
Enter to continue / 'E' to exit.

Checking that other game states have remained the same.
Player 2's hand set to a single copy of test card
Cards in played pile before playing test card 0
Cards in played pile after playing test card: 1
Cards in played pile:
village
Player 2 cards in deck before playing test card: 10
Player 2 cards in deck after playing test ard: 9
Player 2 cards in hand before playing test card: 1
Player 2 cards in hand after playing test card: 1
Top card of deck before playing test card:
copper
Cards in hand after playing test card:
copper
Actions before playing test card: 1
 Actions after playing test card: 2

TEST FAILED: Wrong action count
Enter to continue / 'E' to exit.

Checking that other game states have remained the same.
ONE OR MORE TESTS FAILED
Function 'updateCoins'
Lines executed:81.82% of 11

Function 'gainCard'
Lines executed:0.00% of 13

Function 'discardCard'
Lines executed:84.62% of 13

Function 'cardEffect'
Lines executed:9.22% of 206

Function 'getCost'
Lines executed:0.00% of 30

Function 'drawCard'
Lines executed:36.36% of 22

Function 'getWinners'
Lines executed:0.00% of 24

Function 'scoreFor'
Lines executed:0.00% of 42

Function 'isGameOver'
Lines executed:0.00% of 10

Function 'endTurn'
Lines executed:0.00% of 20

Function 'whoseTurn'
Lines executed:100.00% of 2

Function 'fullDeckCount'
Lines executed:0.00% of 12

Function 'supplyCount'
Lines executed:0.00% of 2

Function 'handCard'
Lines executed:0.00% of 3

Function 'numHandCards'
Lines executed:0.00% of 2

Function 'buyCard'
Lines executed:0.00% of 13

Function 'playCard'
Lines executed:0.00% of 14

Function 'shuffle'
Lines executed:93.75% of 16

Function 'initializeGame'
Lines executed:80.65% of 62

Function 'kingdomCards'
Lines executed:0.00% of 13

Function 'newGame'
Lines executed:0.00% of 3

Function 'compare'
Lines executed:83.33% of 6

Function 'treasure_map_card'
Lines executed:0.00% of 13

Function 'salvager_card'
Lines executed:0.00% of 7

Function 'village_card'
Lines executed:100.00% of 5

Function 'smithy_card'
Lines executed:100.00% of 5

Function 'adventurer_card'
Lines executed:80.00% of 15

Function 'printf'
Lines executed:0.00% of 5

File 'dominion.c'
Lines executed:24.14% of 584
Creating 'dominion.c.gcov'

File 'c:/mingw/include/stdio.h'
Lines executed:0.00% of 5
Creating 'stdio.h.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:4
        -:    0:Programs:4
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        2:    8:void adventurer_card(struct gameState * state, int currentPlayer, int drawnTreasure, int temp_counter,  int temp_hand[])
        -:    9:{
        -:   10:    int cardDrawn; //id of card based on CARD ENUM in dominion.h
        9:   11:    while(drawnTreasure < 2)
        -:   12:    {
        5:   13:        if (state->deckCount[currentPlayer] < 1)
        -:   14:        { //if the deck is empty we need to shuffle discard and add to deck
    #####:   15:            shuffle(currentPlayer, state);
        -:   16:        }
        5:   17:        drawCard(currentPlayer, state);
        5:   18:        cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1]; //top card of hand is most recently drawn card.
        5:   19:        if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)    //if card is a treasure card, increment drawnTreasure
        4:   20:            drawnTreasure++;
        -:   21:        else
        -:   22:        {
        1:   23:            temp_hand[temp_counter] = cardDrawn;
        1:   24:            state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        1:   25:            temp_counter++;
        -:   26:        }
        -:   27:    }
        4:   28:    while (temp_counter - 1 > 0)
        -:   29:    {
    #####:   30:        state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temp_hand[temp_counter - 1]; // discard all cards in play that have been drawn
    #####:   31:        temp_counter = temp_counter - 1;
        -:   32:    }
        2:   33:}
        -:   34:
        2:   35:void smithy_card(struct gameState * state, int currentPlayer, int handPos)
        -:   36:{
        -:   37:    //draw 3 cards
        8:   38:    for(int i = 0; i < 3; i++)
        -:   39:    {
        6:   40:        drawCard(currentPlayer, state);
        -:   41:    }
        -:   42:    //discard card
        2:   43:    discardCard(handPos, currentPlayer, state, 1);
        -:   44:
        2:   45:}
        -:   46:
        2:   47:void village_card(struct gameState * state, int currentPlayer, int handPos)
        -:   48:{
        -:   49:    //Draw card
        2:   50:    drawCard(currentPlayer, state);
        -:   51:    //Add 2 actions
        2:   52:    state->numActions = state->numActions + 1;
        -:   53:    //Discard card after effects are finished
        2:   54:    discardCard(handPos, currentPlayer, state, 0);
        -:   55:
        2:   56:}
        -:   57:
        -:   58://parameters are state struct, int currentPlayer, int card choice, int handPos
    #####:   59:void salvager_card(struct gameState* state , int currentPlayer, int choice, int handPos)
        -:   60:{
        -:   61:    //buys +1
    #####:   62:    state->numBuys++;
    #####:   63:    if(choice)
        -:   64:    {
        -:   65:        //gain coins = to value of card to be discarded
    #####:   66:        state->coins = state->coins + getCost(handCard(choice, state));
        -:   67:        //discard card into destroy pile
    #####:   68:        discardCard(choice, currentPlayer, state, 0);
        -:   69:    }
        -:   70:    //discard the salvager card into recycle pile
    #####:   71:    discardCard(handPos, currentPlayer, state, 0 );
        -:   72:
    #####:   73:}
        -:   74:
        -:   75://parameters are state struct, int currentPlayer, int handPos
    #####:   76:int treasure_map_card(struct gameState * state, int currentPlayer, int handPos)
        -:   77:{
    #####:   78:    int index = -1;
    #####:   79:    for(int i = 0; i < state->handCount[currentPlayer]; i++)
        -:   80:    {
        -:   81:        //if the i'th card is a treasure map that isn't the initial treasure map...
    #####:   82:        if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:   83:        {
    #####:   84:            index = i;
    #####:   85:            break;
        -:   86:        }
        -:   87:
        -:   88:    }
    #####:   89:    if(index > -1) //if a treasure map was found....
        -:   90:    {
        -:   91:        //discard both into the trash pile
    #####:   92:        discardCard(handPos, currentPlayer, state, 1);
    #####:   93:        discardCard(index, currentPlayer, state, 1);
        -:   94:        //gain 4 gold cards
    #####:   95:        for(int i = 0 ; i < 4; i++)
        -:   96:        {
    #####:   97:            gainCard(gold, state, 1, currentPlayer);
        -:   98:        }
    #####:   99:        return 1;
        -:  100:    }
        -:  101:    //else no 2nd treasure map found
    #####:  102:    return 0;
        -:  103:
        -:  104:}
        -:  105:
        -:  106:
        -:  107:
      168:  108:int compare(const void *a, const void *b)
        -:  109:{
      168:  110:  if (*(int *)a > *(int *)b)
    #####:  111:    return 1;
      168:  112:  if (*(int *)a < *(int *)b)
       40:  113:    return -1;
      128:  114:  return 0;
        -:  115:}
        -:  116:
    #####:  117:struct gameState *newGame()
        -:  118:{
    #####:  119:  struct gameState *g = malloc(sizeof(struct gameState));
    #####:  120:  return g;
        -:  121:}
        -:  122:
    #####:  123:int *kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:  124:                  int k8, int k9, int k10)
        -:  125:{
    #####:  126:  int *k = malloc(10 * sizeof(int));
    #####:  127:  k[0] = k1;
    #####:  128:  k[1] = k2;
    #####:  129:  k[2] = k3;
    #####:  130:  k[3] = k4;
    #####:  131:  k[4] = k5;
    #####:  132:  k[5] = k6;
    #####:  133:  k[6] = k7;
    #####:  134:  k[7] = k8;
    #####:  135:  k[8] = k9;
    #####:  136:  k[9] = k10;
    #####:  137:  return k;
        -:  138:}
        -:  139:
        4:  140:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:  141:                   struct gameState *state)
        -:  142:{
        -:  143:
        -:  144:  int i;
        -:  145:  int j;
        -:  146:  int it;
        -:  147:  //set up random number generator
        4:  148:  SelectStream(1);
        4:  149:  PutSeed((long)randomSeed);
        -:  150:
        -:  151:  //check number of players
        4:  152:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:  153:  {
    #####:  154:    return -1;
        -:  155:  }
        -:  156:
        -:  157:  //set number of players
        4:  158:  state->numPlayers = numPlayers;
        -:  159:
        -:  160:  //check selected kingdom cards are different
       44:  161:  for (i = 0; i < 10; i++)
        -:  162:  {
      440:  163:    for (j = 0; j < 10; j++)
        -:  164:    {
      400:  165:      if (j != i && kingdomCards[j] == kingdomCards[i])
        -:  166:      {
    #####:  167:        return -1;
        -:  168:      }
        -:  169:    }
        -:  170:  }
        -:  171:
        -:  172:  //initialize supply
        -:  173:  ///////////////////////////////
        -:  174:
        -:  175:  //set number of Curse cards
        4:  176:  if (numPlayers == 2)
        -:  177:  {
        4:  178:    state->supplyCount[curse] = 10;
        -:  179:  }
    #####:  180:  else if (numPlayers == 3)
        -:  181:  {
    #####:  182:    state->supplyCount[curse] = 20;
        -:  183:  }
        -:  184:  else
        -:  185:  {
    #####:  186:    state->supplyCount[curse] = 30;
        -:  187:  }
        -:  188:
        -:  189:  //set number of Victory cards
        4:  190:  if (numPlayers == 2)
        -:  191:  {
        4:  192:    state->supplyCount[estate] = 8;
        4:  193:    state->supplyCount[duchy] = 8;
        4:  194:    state->supplyCount[province] = 8;
        -:  195:  }
        -:  196:  else
        -:  197:  {
    #####:  198:    state->supplyCount[estate] = 12;
    #####:  199:    state->supplyCount[duchy] = 12;
    #####:  200:    state->supplyCount[province] = 12;
        -:  201:  }
        -:  202:
        -:  203:  //set number of Treasure cards
        4:  204:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        4:  205:  state->supplyCount[silver] = 40;
        4:  206:  state->supplyCount[gold] = 30;
        -:  207:
        -:  208:  //set number of Kingdom cards
       84:  209:  for (i = adventurer; i <= treasure_map; i++) //loop all cards
        -:  210:  {
      660:  211:    for (j = 0; j < 10; j++) //loop chosen cards
        -:  212:    {
      620:  213:      if (kingdomCards[j] == i)
        -:  214:      {
        -:  215:        //check if card is a 'Victory' Kingdom card
       40:  216:        if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  217:        {
    #####:  218:          if (numPlayers == 2)
        -:  219:          {
    #####:  220:            state->supplyCount[i] = 8;
        -:  221:          }
        -:  222:          else
        -:  223:          {
    #####:  224:            state->supplyCount[i] = 12;
        -:  225:          }
        -:  226:        }
        -:  227:        else
        -:  228:        {
       40:  229:          state->supplyCount[i] = 10;
        -:  230:        }
       40:  231:        break;
        -:  232:      }
        -:  233:      else //card is not in the set choosen for the game
        -:  234:      {
      580:  235:        state->supplyCount[i] = -1;
        -:  236:      }
        -:  237:    }
        -:  238:  }
        -:  239:
        -:  240:  ////////////////////////
        -:  241:  //supply intilization complete
        -:  242:
        -:  243:  //set player decks
       12:  244:  for (i = 0; i < numPlayers; i++)
        -:  245:  {
        8:  246:    state->deckCount[i] = 0;
       32:  247:    for (j = 0; j < 3; j++)
        -:  248:    {
       24:  249:      state->deck[i][j] = estate;
       24:  250:      state->deckCount[i]++;
        -:  251:    }
       64:  252:    for (j = 3; j < 10; j++)
        -:  253:    {
       56:  254:      state->deck[i][j] = copper;
       56:  255:      state->deckCount[i]++;
        -:  256:    }
        -:  257:  }
        -:  258:
        -:  259:  //shuffle player decks
       12:  260:  for (i = 0; i < numPlayers; i++)
        -:  261:  {
        8:  262:    if (shuffle(i, state) < 0)
        -:  263:    {
    #####:  264:      return -1;
        -:  265:    }
        -:  266:  }
        -:  267:
        -:  268:  //draw player hands
       12:  269:  for (i = 0; i < numPlayers; i++)
        -:  270:  {
        -:  271:    //initialize hand size to zero
        8:  272:    state->handCount[i] = 0;
        8:  273:    state->discardCount[i] = 0;
        -:  274:    //draw 5 cards
        -:  275:    // for (j = 0; j < 5; j++)
        -:  276:    //	{
        -:  277:    //	  drawCard(i, state);
        -:  278:    //	}
        -:  279:  }
        -:  280:
        -:  281:  //set embargo tokens to 0 for all supply piles
      112:  282:  for (i = 0; i <= treasure_map; i++)
        -:  283:  {
      108:  284:    state->embargoTokens[i] = 0;
        -:  285:  }
        -:  286:
        -:  287:  //initialize first player's turn
        4:  288:  state->outpostPlayed = 0;
        4:  289:  state->phase = 0;
        4:  290:  state->numActions = 1;
        4:  291:  state->numBuys = 1;
        4:  292:  state->playedCardCount = 0;
        4:  293:  state->whoseTurn = 0;
        4:  294:  state->handCount[state->whoseTurn] = 0;
        -:  295:  //int it; move to top
        -:  296:
        -:  297:  //Moved draw cards to here, only drawing at the start of a turn
       24:  298:  for (it = 0; it < 5; it++)
        -:  299:  {
       20:  300:    drawCard(state->whoseTurn, state);
        -:  301:  }
        -:  302:
        4:  303:  updateCoins(state->whoseTurn, state, 0);
        -:  304:
        4:  305:  return 0;
        -:  306:}
        -:  307:
        8:  308:int shuffle(int player, struct gameState *state)
        -:  309:{
        -:  310:
        -:  311:  int newDeck[MAX_DECK];
        8:  312:  int newDeckPos = 0;
        -:  313:  int card;
        -:  314:  int i;
        -:  315:
        8:  316:  if (state->deckCount[player] < 1)
    #####:  317:    return -1;
        8:  318:  qsort((void *)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  319:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  320:
       96:  321:  while (state->deckCount[player] > 0)
        -:  322:  {
       80:  323:    card = floor(Random() * state->deckCount[player]);
       80:  324:    newDeck[newDeckPos] = state->deck[player][card];
       80:  325:    newDeckPos++;
      296:  326:    for (i = card; i < state->deckCount[player] - 1; i++)
        -:  327:    {
      216:  328:      state->deck[player][i] = state->deck[player][i + 1];
        -:  329:    }
       80:  330:    state->deckCount[player]--;
        -:  331:  }
       88:  332:  for (i = 0; i < newDeckPos; i++)
        -:  333:  {
       80:  334:    state->deck[player][i] = newDeck[i];
       80:  335:    state->deckCount[player]++;
        -:  336:  }
        -:  337:
        8:  338:  return 0;
        -:  339:}
        -:  340:
    #####:  341:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  342:{
        -:  343:  int card;
    #####:  344:  int coin_bonus = 0; //tracks coins gain from actions
        -:  345:
        -:  346:  //check if it is the right phase
    #####:  347:  if (state->phase != 0)
        -:  348:  {
    #####:  349:    return -1;
        -:  350:  }
        -:  351:
        -:  352:  //check if player has enough actions
    #####:  353:  if (state->numActions < 1)
        -:  354:  {
    #####:  355:    return -1;
        -:  356:  }
        -:  357:
        -:  358:  //get card played
    #####:  359:  card = handCard(handPos, state);
        -:  360:
        -:  361:  //check if selected card is an action
    #####:  362:  if (card < adventurer || card > treasure_map)
        -:  363:  {
    #####:  364:    return -1;
        -:  365:  }
        -:  366:
        -:  367:  //play card
    #####:  368:  if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  369:  {
    #####:  370:    return -1;
        -:  371:  }
        -:  372:
        -:  373:  //reduce number of actions
    #####:  374:  state->numActions--;
        -:  375:
        -:  376:  //update coins (Treasure cards may be added with card draws)
    #####:  377:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  378:
    #####:  379:  return 0;
        -:  380:}
        -:  381:
    #####:  382:int buyCard(int supplyPos, struct gameState *state)
        -:  383:{
        -:  384:  int who;
        -:  385:  if (DEBUG)
        -:  386:  {
        -:  387:    printf("Entering buyCard...\n");
        -:  388:  }
        -:  389:
        -:  390:  // I don't know what to do about the phase thing.
        -:  391:
    #####:  392:  who = state->whoseTurn;
        -:  393:
    #####:  394:  if (state->numBuys < 1)
        -:  395:  {
        -:  396:    if (DEBUG)
        -:  397:      printf("You do not have any buys left\n");
    #####:  398:    return -1;
        -:  399:  }
    #####:  400:  else if (supplyCount(supplyPos, state) < 1)
        -:  401:  {
        -:  402:    if (DEBUG)
        -:  403:      printf("There are not any of that type of card left\n");
    #####:  404:    return -1;
        -:  405:  }
    #####:  406:  else if (state->coins < getCost(supplyPos))
        -:  407:  {
        -:  408:    if (DEBUG)
        -:  409:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  410:    return -1;
        -:  411:  }
        -:  412:  else
        -:  413:  {
    #####:  414:    state->phase = 1;
        -:  415:    //state->supplyCount[supplyPos]--;
    #####:  416:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  417:
    #####:  418:    state->coins = (state->coins) - (getCost(supplyPos));
    #####:  419:    state->numBuys--;
        -:  420:    if (DEBUG)
        -:  421:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  422:  }
        -:  423:
        -:  424:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  425:  //state->discardCount[who]++;
        -:  426:
    #####:  427:  return 0;
        -:  428:}
        -:  429:
    #####:  430:int numHandCards(struct gameState *state)
        -:  431:{
    #####:  432:  return state->handCount[whoseTurn(state)];
        -:  433:}
        -:  434:
    #####:  435:int handCard(int handPos, struct gameState *state)
        -:  436:{
    #####:  437:  int currentPlayer = whoseTurn(state);
    #####:  438:  return state->hand[currentPlayer][handPos];
        -:  439:}
        -:  440:
    #####:  441:int supplyCount(int card, struct gameState *state)
        -:  442:{
    #####:  443:  return state->supplyCount[card];
        -:  444:}
        -:  445:
    #####:  446:int fullDeckCount(int player, int card, struct gameState *state)
        -:  447:{
        -:  448:  int i;
    #####:  449:  int count = 0;
        -:  450:
    #####:  451:  for (i = 0; i < state->deckCount[player]; i++)
        -:  452:  {
    #####:  453:    if (state->deck[player][i] == card)
    #####:  454:      count++;
        -:  455:  }
        -:  456:
    #####:  457:  for (i = 0; i < state->handCount[player]; i++)
        -:  458:  {
    #####:  459:    if (state->hand[player][i] == card)
    #####:  460:      count++;
        -:  461:  }
        -:  462:
    #####:  463:  for (i = 0; i < state->discardCount[player]; i++)
        -:  464:  {
    #####:  465:    if (state->discard[player][i] == card)
    #####:  466:      count++;
        -:  467:  }
        -:  468:
    #####:  469:  return count;
        -:  470:}
        -:  471:
        8:  472:int whoseTurn(struct gameState *state)
        -:  473:{
        8:  474:  return state->whoseTurn;
        -:  475:}
        -:  476:
    #####:  477:int endTurn(struct gameState *state)
        -:  478:{
        -:  479:  int k;
        -:  480:  int i;
    #####:  481:  int currentPlayer = whoseTurn(state);
        -:  482:
        -:  483:  //Discard hand
    #####:  484:  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  485:  {
    #####:  486:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i]; //Discard
    #####:  487:    state->hand[currentPlayer][i] = -1;                                                                  //Set card to -1
        -:  488:  }
    #####:  489:  state->handCount[currentPlayer] = 0; //Reset hand count
        -:  490:
        -:  491:  //Code for determining the player
    #####:  492:  if (currentPlayer < (state->numPlayers - 1))
        -:  493:  {
    #####:  494:    state->whoseTurn = currentPlayer + 1; //Still safe to increment
        -:  495:  }
        -:  496:  else
        -:  497:  {
    #####:  498:    state->whoseTurn = 0; //Max player has been reached, loop back around to player 1
        -:  499:  }
        -:  500:
    #####:  501:  state->outpostPlayed = 0;
    #####:  502:  state->phase = 0;
    #####:  503:  state->numActions = 1;
    #####:  504:  state->coins = 0;
    #####:  505:  state->numBuys = 1;
    #####:  506:  state->playedCardCount = 0;
    #####:  507:  state->handCount[state->whoseTurn] = 0;
        -:  508:
        -:  509:  //int k; move to top
        -:  510:  //Next player draws hand
    #####:  511:  for (k = 0; k < 5; k++)
        -:  512:  {
    #####:  513:    drawCard(state->whoseTurn, state); //Draw a card
        -:  514:  }
        -:  515:
        -:  516:  //Update money
    #####:  517:  updateCoins(state->whoseTurn, state, 0);
        -:  518:
    #####:  519:  return 0;
        -:  520:}
        -:  521:
    #####:  522:int isGameOver(struct gameState *state)
        -:  523:{
        -:  524:  int i;
        -:  525:  int j;
        -:  526:
        -:  527:  //if stack of Province cards is empty, the game ends
    #####:  528:  if (state->supplyCount[province] == 0)
        -:  529:  {
    #####:  530:    return 1;
        -:  531:  }
        -:  532:
        -:  533:  //if three supply pile are at 0, the game ends
    #####:  534:  j = 0;
    #####:  535:  for (i = 0; i < 25; i++)
        -:  536:  {
    #####:  537:    if (state->supplyCount[i] == 0)
        -:  538:    {
    #####:  539:      j++;
        -:  540:    }
        -:  541:  }
    #####:  542:  if (j >= 3)
        -:  543:  {
    #####:  544:    return 1;
        -:  545:  }
        -:  546:
    #####:  547:  return 0;
        -:  548:}
        -:  549:
    #####:  550:int scoreFor(int player, struct gameState *state)
        -:  551:{
        -:  552:
        -:  553:  int i;
    #####:  554:  int score = 0;
        -:  555:  //score from hand
    #####:  556:  for (i = 0; i < state->handCount[player]; i++)
        -:  557:  {
    #####:  558:    if (state->hand[player][i] == curse)
        -:  559:    {
    #####:  560:      score = score - 1;
        -:  561:    };
    #####:  562:    if (state->hand[player][i] == estate)
        -:  563:    {
    #####:  564:      score = score + 1;
        -:  565:    };
    #####:  566:    if (state->hand[player][i] == duchy)
        -:  567:    {
    #####:  568:      score = score + 3;
        -:  569:    };
    #####:  570:    if (state->hand[player][i] == province)
        -:  571:    {
    #####:  572:      score = score + 6;
        -:  573:    };
    #####:  574:    if (state->hand[player][i] == great_hall)
        -:  575:    {
    #####:  576:      score = score + 1;
        -:  577:    };
    #####:  578:    if (state->hand[player][i] == gardens)
        -:  579:    {
    #####:  580:      score = score + (fullDeckCount(player, 0, state) / 10);
        -:  581:    };
        -:  582:  }
        -:  583:
        -:  584:  //score from discard
    #####:  585:  for (i = 0; i < state->discardCount[player]; i++)
        -:  586:  {
    #####:  587:    if (state->discard[player][i] == curse)
        -:  588:    {
    #####:  589:      score = score - 1;
        -:  590:    };
    #####:  591:    if (state->discard[player][i] == estate)
        -:  592:    {
    #####:  593:      score = score + 1;
        -:  594:    };
    #####:  595:    if (state->discard[player][i] == duchy)
        -:  596:    {
    #####:  597:      score = score + 3;
        -:  598:    };
    #####:  599:    if (state->discard[player][i] == province)
        -:  600:    {
    #####:  601:      score = score + 6;
        -:  602:    };
    #####:  603:    if (state->discard[player][i] == great_hall)
        -:  604:    {
    #####:  605:      score = score + 1;
        -:  606:    };
    #####:  607:    if (state->discard[player][i] == gardens)
        -:  608:    {
    #####:  609:      score = score + (fullDeckCount(player, 0, state) / 10);
        -:  610:    };
        -:  611:  }
        -:  612:
        -:  613:  //score from deck
    #####:  614:  for (i = 0; i < state->discardCount[player]; i++)
        -:  615:  {
    #####:  616:    if (state->deck[player][i] == curse)
        -:  617:    {
    #####:  618:      score = score - 1;
        -:  619:    };
    #####:  620:    if (state->deck[player][i] == estate)
        -:  621:    {
    #####:  622:      score = score + 1;
        -:  623:    };
    #####:  624:    if (state->deck[player][i] == duchy)
        -:  625:    {
    #####:  626:      score = score + 3;
        -:  627:    };
    #####:  628:    if (state->deck[player][i] == province)
        -:  629:    {
    #####:  630:      score = score + 6;
        -:  631:    };
    #####:  632:    if (state->deck[player][i] == great_hall)
        -:  633:    {
    #####:  634:      score = score + 1;
        -:  635:    };
    #####:  636:    if (state->deck[player][i] == gardens)
        -:  637:    {
    #####:  638:      score = score + (fullDeckCount(player, 0, state) / 10);
        -:  639:    };
        -:  640:  }
        -:  641:
    #####:  642:  return score;
        -:  643:}
        -:  644:
    #####:  645:int getWinners(int players[MAX_PLAYERS], struct gameState *state)
        -:  646:{
        -:  647:  int i;
        -:  648:  int j;
        -:  649:  int highScore;
        -:  650:  int currentPlayer;
        -:  651:
        -:  652:  //get score for each player
    #####:  653:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  654:  {
        -:  655:    //set unused player scores to -9999
    #####:  656:    if (i >= state->numPlayers)
        -:  657:    {
    #####:  658:      players[i] = -9999;
        -:  659:    }
        -:  660:    else
        -:  661:    {
    #####:  662:      players[i] = scoreFor(i, state);
        -:  663:    }
        -:  664:  }
        -:  665:
        -:  666:  //find highest score
    #####:  667:  j = 0;
    #####:  668:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  669:  {
    #####:  670:    if (players[i] > players[j])
        -:  671:    {
    #####:  672:      j = i;
        -:  673:    }
        -:  674:  }
    #####:  675:  highScore = players[j];
        -:  676:
        -:  677:  //add 1 to players who had less turns
    #####:  678:  currentPlayer = whoseTurn(state);
    #####:  679:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  680:  {
    #####:  681:    if (players[i] == highScore && i > currentPlayer)
        -:  682:    {
    #####:  683:      players[i]++;
        -:  684:    }
        -:  685:  }
        -:  686:
        -:  687:  //find new highest score
    #####:  688:  j = 0;
    #####:  689:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  690:  {
    #####:  691:    if (players[i] > players[j])
        -:  692:    {
    #####:  693:      j = i;
        -:  694:    }
        -:  695:  }
    #####:  696:  highScore = players[j];
        -:  697:
        -:  698:  //set winners in array to 1 and rest to 0
    #####:  699:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  700:  {
    #####:  701:    if (players[i] == highScore)
        -:  702:    {
    #####:  703:      players[i] = 1;
        -:  704:    }
        -:  705:    else
        -:  706:    {
    #####:  707:      players[i] = 0;
        -:  708:    }
        -:  709:  }
        -:  710:
    #####:  711:  return 0;
        -:  712:}
        -:  713:
       35:  714:int drawCard(int player, struct gameState *state)
        -:  715:{
        -:  716:  int count;
        -:  717:  int deckCounter;
       35:  718:  if (state->deckCount[player] <= 0)
        -:  719:  { //Deck is empty
        -:  720:
        -:  721:    //Step 1 Shuffle the discard pile back into a deck
        -:  722:    int i;
        -:  723:    //Move discard to deck
    #####:  724:    for (i = 0; i < state->discardCount[player]; i++)
        -:  725:    {
    #####:  726:      state->deck[player][i] = state->discard[player][i];
    #####:  727:      state->discard[player][i] = -1;
        -:  728:    }
        -:  729:
    #####:  730:    state->deckCount[player] = state->discardCount[player];
    #####:  731:    state->discardCount[player] = 0; //Reset discard
        -:  732:
        -:  733:    //Shufffle the deck
    #####:  734:    shuffle(player, state); //Shuffle the deck up and make it so that we can draw
        -:  735:
        -:  736:    if (DEBUG)
        -:  737:    { //Debug statements
        -:  738:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  739:    }
        -:  740:
    #####:  741:    state->discardCount[player] = 0;
        -:  742:
        -:  743:    //Step 2 Draw Card
    #####:  744:    count = state->handCount[player]; //Get current player's hand count
        -:  745:
        -:  746:    if (DEBUG)
        -:  747:    { //Debug statements
        -:  748:      printf("Current hand count: %d\n", count);
        -:  749:    }
        -:  750:
    #####:  751:    deckCounter = state->deckCount[player]; //Create a holder for the deck count
        -:  752:
    #####:  753:    if (deckCounter == 0)
    #####:  754:      return -1;
        -:  755:
    #####:  756:    state->hand[player][count] = state->deck[player][deckCounter - 1]; //Add card to hand
    #####:  757:    state->deckCount[player]--;
    #####:  758:    state->handCount[player]++; //Increment hand count
        -:  759:  }
        -:  760:
        -:  761:  else
        -:  762:  {
       35:  763:    int count = state->handCount[player]; //Get current hand count for player
        -:  764:    int deckCounter;
        -:  765:    if (DEBUG)
        -:  766:    { //Debug statements
        -:  767:      printf("Current hand count: %d\n", count);
        -:  768:    }
        -:  769:
       35:  770:    deckCounter = state->deckCount[player];                            //Create holder for the deck count
       35:  771:    state->hand[player][count] = state->deck[player][deckCounter - 1]; //Add card to the hand
       35:  772:    state->deckCount[player]--;
       35:  773:    state->handCount[player]++; //Increment hand count
        -:  774:  }
        -:  775:
       35:  776:  return 0;
        -:  777:}
        -:  778:
    #####:  779:int getCost(int cardNumber)
        -:  780:{
    #####:  781:  switch (cardNumber)
        -:  782:  {
        -:  783:  case curse:
    #####:  784:    return 0;
        -:  785:  case estate:
    #####:  786:    return 2;
        -:  787:  case duchy:
    #####:  788:    return 5;
        -:  789:  case province:
    #####:  790:    return 8;
        -:  791:  case copper:
    #####:  792:    return 0;
        -:  793:  case silver:
    #####:  794:    return 3;
        -:  795:  case gold:
    #####:  796:    return 6;
        -:  797:  case adventurer:
    #####:  798:    return 6;
        -:  799:  case council_room:
    #####:  800:    return 5;
        -:  801:  case feast:
    #####:  802:    return 4;
        -:  803:  case gardens:
    #####:  804:    return 4;
        -:  805:  case mine:
    #####:  806:    return 5;
        -:  807:  case remodel:
    #####:  808:    return 4;
        -:  809:  case smithy:
    #####:  810:    return 4;
        -:  811:  case village:
    #####:  812:    return 3;
        -:  813:  case baron:
    #####:  814:    return 4;
        -:  815:  case great_hall:
    #####:  816:    return 3;
        -:  817:  case minion:
    #####:  818:    return 5;
        -:  819:  case steward:
    #####:  820:    return 3;
        -:  821:  case tribute:
    #####:  822:    return 5;
        -:  823:  case ambassador:
    #####:  824:    return 3;
        -:  825:  case cutpurse:
    #####:  826:    return 4;
        -:  827:  case embargo:
    #####:  828:    return 2;
        -:  829:  case outpost:
    #####:  830:    return 5;
        -:  831:  case salvager:
    #####:  832:    return 4;
        -:  833:  case sea_hag:
    #####:  834:    return 4;
        -:  835:  case treasure_map:
    #####:  836:    return 4;
        -:  837:  }
        -:  838:
    #####:  839:  return -1;
        -:  840:}
        -:  841:
        8:  842:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  843:{
        -:  844:  int i;
        -:  845:  int j;
        -:  846:  int k;
        -:  847:  int x;
        -:  848:  int index;
        8:  849:  int currentPlayer = whoseTurn(state);
        8:  850:  int nextPlayer = currentPlayer + 1;
        -:  851:
        8:  852:  int tributeRevealedCards[2] = {-1, -1};
        -:  853:  int temphand[MAX_HAND]; // moved above the if statement
        8:  854:  int drawntreasure = 0;
        -:  855:  int cardDrawn;
        8:  856:  int z = 0; // this is the counter for the temp hand
        8:  857:  if (nextPlayer > (state->numPlayers - 1))
        -:  858:  {
        4:  859:    nextPlayer = 0;
        -:  860:  }
        -:  861:
        -:  862:  //uses switch to select card and perform actions
        8:  863:  switch (card)
        -:  864:  {
        -:  865:  case adventurer:
        2:  866:    adventurer_card(state, currentPlayer, drawntreasure, z, temphand);
        -:  867:    /*
        -:  868:    while (drawntreasure < 2)
        -:  869:    {
        -:  870:      if (state->deckCount[currentPlayer] < 1)
        -:  871:      { //if the deck is empty we need to shuffle discard and add to deck
        -:  872:        shuffle(currentPlayer, state);
        -:  873:      }
        -:  874:      drawCard(currentPlayer, state);
        -:  875:      cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1]; //top card of hand is most recently drawn card.
        -:  876:      if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  877:        drawntreasure++;
        -:  878:      else
        -:  879:      {
        -:  880:        temphand[z] = cardDrawn;
        -:  881:        state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        -:  882:        z++;
        -:  883:      }
        -:  884:    }
        -:  885:    while (z - 1 >= 0)
        -:  886:    {
        -:  887:      state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
        -:  888:      z = z - 1;
        -:  889:    }
        -:  890:    */
        2:  891:    return 0;
        -:  892:
        -:  893:  case council_room:
        -:  894:    //+4 Cards
    #####:  895:    for (i = 0; i < 4; i++)
        -:  896:    {
    #####:  897:      drawCard(currentPlayer, state);
        -:  898:    }
        -:  899:
        -:  900:    //+1 Buy
    #####:  901:    state->numBuys++;
        -:  902:
        -:  903:    //Each other player draws a card
    #####:  904:    for (i = 0; i < state->numPlayers; i++)
        -:  905:    {
    #####:  906:      if (i != currentPlayer)
        -:  907:      {
    #####:  908:        drawCard(i, state);
        -:  909:      }
        -:  910:    }
        -:  911:
        -:  912:    //put played card in played card pile
    #####:  913:    discardCard(handPos, currentPlayer, state, 0);
        -:  914:
    #####:  915:    return 0;
        -:  916:
        -:  917:  case feast:
        -:  918:    //gain card with cost up to 5
        -:  919:    //Backup hand
    #####:  920:    for (i = 0; i <= state->handCount[currentPlayer]; i++)
        -:  921:    {
    #####:  922:      temphand[i] = state->hand[currentPlayer][i]; //Backup card
    #####:  923:      state->hand[currentPlayer][i] = -1;          //Set to nothing
        -:  924:    }
        -:  925:    //Backup hand
        -:  926:
        -:  927:    //Update Coins for Buy
    #####:  928:    updateCoins(currentPlayer, state, 5);
    #####:  929:    x = 1; //Condition to loop on
    #####:  930:    while (x == 1)
        -:  931:    { //Buy one card
    #####:  932:      if (supplyCount(choice1, state) <= 0)
        -:  933:      {
        -:  934:        if (DEBUG)
        -:  935:          printf("None of that card left, sorry!\n");
        -:  936:
        -:  937:        if (DEBUG)
        -:  938:        {
        -:  939:          printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  940:        }
        -:  941:      }
    #####:  942:      else if (state->coins < getCost(choice1))
        -:  943:      {
    #####:  944:        printf("That card is too expensive!\n");
        -:  945:
        -:  946:        if (DEBUG)
        -:  947:        {
        -:  948:          printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  949:        }
        -:  950:      }
        -:  951:      else
        -:  952:      {
        -:  953:
        -:  954:        if (DEBUG)
        -:  955:        {
        -:  956:          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  957:        }
        -:  958:
    #####:  959:        gainCard(choice1, state, 0, currentPlayer); //Gain the card
    #####:  960:        x = 0;                                      //No more buying cards
        -:  961:
        -:  962:        if (DEBUG)
        -:  963:        {
        -:  964:          printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  965:        }
        -:  966:      }
        -:  967:    }
        -:  968:
        -:  969:    //Reset Hand
    #####:  970:    for (i = 0; i <= state->handCount[currentPlayer]; i++)
        -:  971:    {
    #####:  972:      state->hand[currentPlayer][i] = temphand[i];
    #####:  973:      temphand[i] = -1;
        -:  974:    }
        -:  975:    //Reset Hand
        -:  976:
    #####:  977:    return 0;
        -:  978:
        -:  979:  case gardens:
    #####:  980:    return -1;
        -:  981:
        -:  982:  case mine:
    #####:  983:    j = state->hand[currentPlayer][choice1]; //store card we will trash
        -:  984:
    #####:  985:    if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  986:    {
    #####:  987:      return -1;
        -:  988:    }
        -:  989:
    #####:  990:    if (choice2 > treasure_map || choice2 < curse)
        -:  991:    {
    #####:  992:      return -1;
        -:  993:    }
        -:  994:
    #####:  995:    if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  996:    {
    #####:  997:      return -1;
        -:  998:    }
        -:  999:
    #####: 1000:    gainCard(choice2, state, 2, currentPlayer);
        -: 1001:
        -: 1002:    //discard card from hand
    #####: 1003:    discardCard(handPos, currentPlayer, state, 0);
        -: 1004:
        -: 1005:    //discard trashed card
    #####: 1006:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1007:    {
    #####: 1008:      if (state->hand[currentPlayer][i] == j)
        -: 1009:      {
    #####: 1010:        discardCard(i, currentPlayer, state, 0);
    #####: 1011:        break;
        -: 1012:      }
        -: 1013:    }
        -: 1014:
    #####: 1015:    return 0;
        -: 1016:
        -: 1017:  case remodel:
    #####: 1018:    j = state->hand[currentPlayer][choice1]; //store card we will trash
        -: 1019:
    #####: 1020:    if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -: 1021:    {
    #####: 1022:      return -1;
        -: 1023:    }
        -: 1024:
    #####: 1025:    gainCard(choice2, state, 0, currentPlayer);
        -: 1026:
        -: 1027:    //discard card from hand
    #####: 1028:    discardCard(handPos, currentPlayer, state, 0);
        -: 1029:
        -: 1030:    //discard trashed card
    #####: 1031:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1032:    {
    #####: 1033:      if (state->hand[currentPlayer][i] == j)
        -: 1034:      {
    #####: 1035:        discardCard(i, currentPlayer, state, 0);
    #####: 1036:        break;
        -: 1037:      }
        -: 1038:    }
        -: 1039:
    #####: 1040:    return 0;
        -: 1041:
        -: 1042:  case smithy:
        2: 1043:    smithy_card(state, currentPlayer, handPos);
        -: 1044:    //+3 Cards
        -: 1045:    /*
        -: 1046:    for (i = 0; i < 3; i++)
        -: 1047:    {
        -: 1048:      drawCard(currentPlayer, state);
        -: 1049:    }
        -: 1050:
        -: 1051:    //discard card from hand
        -: 1052:    discardCard(handPos, currentPlayer, state, 0);
        -: 1053:    */
        2: 1054:    return 0;
        -: 1055:
        -: 1056:  case village:
        2: 1057:    village_card(state, currentPlayer, handPos);
        -: 1058:    //+1 Card
        -: 1059:    /*
        -: 1060:    drawCard(currentPlayer, state);
        -: 1061:
        -: 1062:    //+2 Actions
        -: 1063:    state->numActions = state->numActions + 2;
        -: 1064:
        -: 1065:    //discard played card from hand
        -: 1066:    discardCard(handPos, currentPlayer, state, 0);
        -: 1067:    */
        2: 1068:    return 0;
        -: 1069:
        -: 1070:  case baron:
    #####: 1071:    state->numBuys++; //Increase buys by 1!
    #####: 1072:    if (choice1 > 0)
        -: 1073:    {                             //Boolean true or going to discard an estate
    #####: 1074:      int p = 0;                  //Iterator for hand!
    #####: 1075:      int card_not_discarded = 1; //Flag for discard set!
    #####: 1076:      while (card_not_discarded)
        -: 1077:      {
    #####: 1078:        if (state->hand[currentPlayer][p] == estate)
        -: 1079:        {                    //Found an estate card!
    #####: 1080:          state->coins += 4; //Add 4 coins to the amount of coins
    #####: 1081:          state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1082:          state->discardCount[currentPlayer]++;
    #####: 1083:          for (; p < state->handCount[currentPlayer]; p++)
        -: 1084:          {
    #####: 1085:            state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -: 1086:          }
    #####: 1087:          state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1088:          state->handCount[currentPlayer]--;
    #####: 1089:          card_not_discarded = 0; //Exit the loop
        -: 1090:        }
    #####: 1091:        else if (p > state->handCount[currentPlayer])
        -: 1092:        {
        -: 1093:          if (DEBUG)
        -: 1094:          {
        -: 1095:            printf("No estate cards in your hand, invalid choice\n");
        -: 1096:            printf("Must gain an estate if there are any\n");
        -: 1097:          }
    #####: 1098:          if (supplyCount(estate, state) > 0)
        -: 1099:          {
    #####: 1100:            gainCard(estate, state, 0, currentPlayer);
    #####: 1101:            state->supplyCount[estate]--; //Decrement estates
    #####: 1102:            if (supplyCount(estate, state) == 0)
        -: 1103:            {
    #####: 1104:              isGameOver(state);
        -: 1105:            }
        -: 1106:          }
    #####: 1107:          card_not_discarded = 0; //Exit the loop
        -: 1108:        }
        -: 1109:
        -: 1110:        else
        -: 1111:        {
    #####: 1112:          p++; //Next card
        -: 1113:        }
        -: 1114:      }
        -: 1115:    }
        -: 1116:
        -: 1117:    else
        -: 1118:    {
    #####: 1119:      if (supplyCount(estate, state) > 0)
        -: 1120:      {
    #####: 1121:        gainCard(estate, state, 0, currentPlayer); //Gain an estate
    #####: 1122:        state->supplyCount[estate]--;              //Decrement Estates
    #####: 1123:        if (supplyCount(estate, state) == 0)
        -: 1124:        {
    #####: 1125:          isGameOver(state);
        -: 1126:        }
        -: 1127:      }
        -: 1128:    }
        -: 1129:
    #####: 1130:    return 0;
        -: 1131:
        -: 1132:  case great_hall:
        -: 1133:    //+1 Card
        2: 1134:    drawCard(currentPlayer, state);
        -: 1135:
        -: 1136:    //+1 Actions
        2: 1137:    state->numActions++;
        -: 1138:
        -: 1139:    //discard card from hand
        2: 1140:    discardCard(handPos, currentPlayer, state, 0);
        2: 1141:    return 0;
        -: 1142:
        -: 1143:  case minion:
        -: 1144:    //+1 action
    #####: 1145:    state->numActions++;
        -: 1146:
        -: 1147:    //discard card from hand
    #####: 1148:    discardCard(handPos, currentPlayer, state, 0);
        -: 1149:
    #####: 1150:    if (choice1) //+2 coins
        -: 1151:    {
    #####: 1152:      state->coins = state->coins + 2;
        -: 1153:    }
        -: 1154:
    #####: 1155:    else if (choice2) //discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1156:    {
        -: 1157:      //discard hand
    #####: 1158:      while (numHandCards(state) > 0)
        -: 1159:      {
    #####: 1160:        discardCard(handPos, currentPlayer, state, 0);
        -: 1161:      }
        -: 1162:
        -: 1163:      //draw 4
    #####: 1164:      for (i = 0; i < 4; i++)
        -: 1165:      {
    #####: 1166:        drawCard(currentPlayer, state);
        -: 1167:      }
        -: 1168:
        -: 1169:      //other players discard hand and redraw if hand size > 4
    #####: 1170:      for (i = 0; i < state->numPlayers; i++)
        -: 1171:      {
    #####: 1172:        if (i != currentPlayer)
        -: 1173:        {
    #####: 1174:          if (state->handCount[i] > 4)
        -: 1175:          {
        -: 1176:            //discard hand
    #####: 1177:            while (state->handCount[i] > 0)
        -: 1178:            {
    #####: 1179:              discardCard(handPos, i, state, 0);
        -: 1180:            }
        -: 1181:
        -: 1182:            //draw 4
    #####: 1183:            for (j = 0; j < 4; j++)
        -: 1184:            {
    #####: 1185:              drawCard(i, state);
        -: 1186:            }
        -: 1187:          }
        -: 1188:        }
        -: 1189:      }
        -: 1190:    }
    #####: 1191:    return 0;
        -: 1192:
        -: 1193:  case steward:
    #####: 1194:    if (choice1 == 1)
        -: 1195:    {
        -: 1196:      //+2 cards
    #####: 1197:      drawCard(currentPlayer, state);
    #####: 1198:      drawCard(currentPlayer, state);
        -: 1199:    }
    #####: 1200:    else if (choice1 == 2)
        -: 1201:    {
        -: 1202:      //+2 coins
    #####: 1203:      state->coins = state->coins + 2;
        -: 1204:    }
        -: 1205:    else
        -: 1206:    {
        -: 1207:      //trash 2 cards in hand
    #####: 1208:      discardCard(choice2, currentPlayer, state, 1);
    #####: 1209:      discardCard(choice3, currentPlayer, state, 1);
        -: 1210:    }
        -: 1211:
        -: 1212:    //discard card from hand
    #####: 1213:    discardCard(handPos, currentPlayer, state, 0);
    #####: 1214:    return 0;
        -: 1215:
        -: 1216:  case tribute:
    #####: 1217:    if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1)
        -: 1218:    {
    #####: 1219:      if (state->deckCount[nextPlayer] > 0)
        -: 1220:      {
    #####: 1221:        tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1222:        state->deckCount[nextPlayer]--;
        -: 1223:      }
    #####: 1224:      else if (state->discardCount[nextPlayer] > 0)
        -: 1225:      {
    #####: 1226:        tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1227:        state->discardCount[nextPlayer]--;
        -: 1228:      }
        -: 1229:      else
        -: 1230:      {
        -: 1231:        //No Card to Reveal
        -: 1232:        if (DEBUG)
        -: 1233:        {
        -: 1234:          printf("No cards to reveal\n");
        -: 1235:        }
        -: 1236:      }
        -: 1237:    }
        -: 1238:
        -: 1239:    else
        -: 1240:    {
    #####: 1241:      if (state->deckCount[nextPlayer] == 0)
        -: 1242:      {
    #####: 1243:        for (i = 0; i < state->discardCount[nextPlayer]; i++)
        -: 1244:        {
    #####: 1245:          state->deck[nextPlayer][i] = state->discard[nextPlayer][i]; //Move to deck
    #####: 1246:          state->deckCount[nextPlayer]++;
    #####: 1247:          state->discard[nextPlayer][i] = -1;
    #####: 1248:          state->discardCount[nextPlayer]--;
        -: 1249:        }
        -: 1250:
    #####: 1251:        shuffle(nextPlayer, state); //Shuffle the deck
        -: 1252:      }
    #####: 1253:      tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1254:      state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1255:      state->deckCount[nextPlayer]--;
    #####: 1256:      tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1257:      state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1258:      state->deckCount[nextPlayer]--;
        -: 1259:    }
        -: 1260:
    #####: 1261:    if (tributeRevealedCards[0] == tributeRevealedCards[1])
        -: 1262:    { //If we have a duplicate card, just drop one
    #####: 1263:      state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1264:      state->playedCardCount++;
    #####: 1265:      tributeRevealedCards[1] = -1;
        -: 1266:    }
        -: 1267:
    #####: 1268:    for (i = 0; i <= 2; i++)
        -: 1269:    {
    #####: 1270:      if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold)
        -: 1271:      { //Treasure cards
    #####: 1272:        state->coins += 2;
        -: 1273:      }
        -: 1274:
    #####: 1275:      else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall)
        -: 1276:      { //Victory Card Found
    #####: 1277:        drawCard(currentPlayer, state);
    #####: 1278:        drawCard(currentPlayer, state);
        -: 1279:      }
        -: 1280:      else
        -: 1281:      { //Action Card
    #####: 1282:        state->numActions = state->numActions + 2;
        -: 1283:      }
        -: 1284:    }
        -: 1285:
    #####: 1286:    return 0;
        -: 1287:
        -: 1288:  case ambassador:
    #####: 1289:    j = 0; //used to check if player has enough cards to discard
        -: 1290:
    #####: 1291:    if (choice2 > 2 || choice2 < 0)
        -: 1292:    {
    #####: 1293:      return -1;
        -: 1294:    }
        -: 1295:
    #####: 1296:    if (choice1 == handPos)
        -: 1297:    {
    #####: 1298:      return -1;
        -: 1299:    }
        -: 1300:
    #####: 1301:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1302:    {
    #####: 1303:      if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1304:      {
    #####: 1305:        j++;
        -: 1306:      }
        -: 1307:    }
    #####: 1308:    if (j < choice2)
        -: 1309:    {
    #####: 1310:      return -1;
        -: 1311:    }
        -: 1312:
        -: 1313:    if (DEBUG)
        -: 1314:      printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1315:
        -: 1316:    //increase supply count for choosen card by amount being discarded
    #####: 1317:    state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1318:
        -: 1319:    //each other player gains a copy of revealed card
    #####: 1320:    for (i = 0; i < state->numPlayers; i++)
        -: 1321:    {
    #####: 1322:      if (i != currentPlayer)
        -: 1323:      {
    #####: 1324:        gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1325:      }
        -: 1326:    }
        -: 1327:
        -: 1328:    //discard played card from hand
    #####: 1329:    discardCard(handPos, currentPlayer, state, 0);
        -: 1330:
        -: 1331:    //trash copies of cards returned to supply
    #####: 1332:    for (j = 0; j < choice2; j++)
        -: 1333:    {
    #####: 1334:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1335:      {
    #####: 1336:        if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1337:        {
    #####: 1338:          discardCard(i, currentPlayer, state, 1);
    #####: 1339:          break;
        -: 1340:        }
        -: 1341:      }
        -: 1342:    }
        -: 1343:
    #####: 1344:    return 0;
        -: 1345:
        -: 1346:  case cutpurse:
        -: 1347:
    #####: 1348:    updateCoins(currentPlayer, state, 2);
    #####: 1349:    for (i = 0; i < state->numPlayers; i++)
        -: 1350:    {
    #####: 1351:      if (i != currentPlayer)
        -: 1352:      {
    #####: 1353:        for (j = 0; j < state->handCount[i]; j++)
        -: 1354:        {
    #####: 1355:          if (state->hand[i][j] == copper)
        -: 1356:          {
    #####: 1357:            discardCard(j, i, state, 0);
    #####: 1358:            break;
        -: 1359:          }
    #####: 1360:          if (j == state->handCount[i])
        -: 1361:          {
    #####: 1362:            for (k = 0; k < state->handCount[i]; k++)
        -: 1363:            {
        -: 1364:              if (DEBUG)
        -: 1365:                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1366:            }
    #####: 1367:            break;
        -: 1368:          }
        -: 1369:        }
        -: 1370:      }
        -: 1371:    }
        -: 1372:
        -: 1373:    //discard played card from hand
    #####: 1374:    discardCard(handPos, currentPlayer, state, 0);
        -: 1375:
    #####: 1376:    return 0;
        -: 1377:
        -: 1378:  case embargo:
        -: 1379:    //+2 Coins
    #####: 1380:    state->coins = state->coins + 2;
        -: 1381:
        -: 1382:    //see if selected pile is in play
    #####: 1383:    if (state->supplyCount[choice1] == -1)
        -: 1384:    {
    #####: 1385:      return -1;
        -: 1386:    }
        -: 1387:
        -: 1388:    //add embargo token to selected supply pile
    #####: 1389:    state->embargoTokens[choice1]++;
        -: 1390:
        -: 1391:    //trash card
    #####: 1392:    discardCard(handPos, currentPlayer, state, 1);
    #####: 1393:    return 0;
        -: 1394:
        -: 1395:  case outpost:
        -: 1396:    //set outpost flag
    #####: 1397:    state->outpostPlayed++;
        -: 1398:
        -: 1399:    //discard card
    #####: 1400:    discardCard(handPos, currentPlayer, state, 0);
    #####: 1401:    return 0;
        -: 1402:
        -: 1403:  case salvager:
    #####: 1404:    salvager_card(state, currentPlayer, choice1, handPos);
        -: 1405:    /*
        -: 1406:    //+1 buy
        -: 1407:    state->numBuys++;
        -: 1408:
        -: 1409:    if (choice1)
        -: 1410:    {
        -: 1411:      //gain coins equal to trashed card
        -: 1412:      state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1413:      //trash card
        -: 1414:      discardCard(choice1, currentPlayer, state, 1);
        -: 1415:    }
        -: 1416:
        -: 1417:    //discard card
        -: 1418:    discardCard(handPos, currentPlayer, state, 0);
        -: 1419:    */
    #####: 1420:    return 0;
        -: 1421:
        -: 1422:  case sea_hag:
    #####: 1423:    for (i = 0; i < state->numPlayers; i++)
        -: 1424:    {
    #####: 1425:      if (i != currentPlayer)
        -: 1426:      {
    #####: 1427:        state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];
    #####: 1428:        state->deckCount[i]--;
    #####: 1429:        state->discardCount[i]++;
    #####: 1430:        state->deck[i][state->deckCount[i]--] = curse; //Top card now a curse
        -: 1431:      }
        -: 1432:    }
    #####: 1433:    return 0;
        -: 1434:
        -: 1435:  case treasure_map:
    #####: 1436:    return treasure_map_card(state, currentPlayer, handPos);
        -: 1437:    //search hand for another treasure_map
        -: 1438:    /*
        -: 1439:    index = -1;
        -: 1440:    for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1441:    {
        -: 1442:      if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1443:      {
        -: 1444:        index = i;
        -: 1445:        break;
        -: 1446:      }
        -: 1447:    }
        -: 1448:    if (index > -1)
        -: 1449:    {
        -: 1450:      //trash both treasure cards
        -: 1451:      discardCard(handPos, currentPlayer, state, 1);
        -: 1452:      discardCard(index, currentPlayer, state, 1);
        -: 1453:
        -: 1454:      //gain 4 Gold cards
        -: 1455:      for (i = 0; i < 4; i++)
        -: 1456:      {
        -: 1457:        gainCard(gold, state, 1, currentPlayer);
        -: 1458:      }
        -: 1459:
        -: 1460:      //return success
        -: 1461:      return 1;
        -: 1462:    }
        -: 1463:
        -: 1464:    //no second treasure_map found in hand
        -: 1465:    return -1;
        -: 1466:     */
        -: 1467:  }
        -: 1468: 
    #####: 1469:  return -1;
        -: 1470:}
        -: 1471:
        6: 1472:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1473:{
        -: 1474:
        -: 1475:  //if card is not trashed, added to Played pile
        6: 1476:  if (trashFlag < 1)
        -: 1477:  {
        -: 1478:    //add card to played pile
        4: 1479:    state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
        4: 1480:    state->playedCardCount++;
        -: 1481:  }
        -: 1482:
        -: 1483:  //set played card to -1
        6: 1484:  state->hand[currentPlayer][handPos] = -1;
        -: 1485:
        -: 1486:  //remove card from player's hand
        6: 1487:  if (handPos == (state->handCount[currentPlayer] - 1)) //last card in hand array is played
        -: 1488:  {
        -: 1489:    //reduce number of cards in hand
    #####: 1490:    state->handCount[currentPlayer]--;
        -: 1491:  }
        6: 1492:  else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1493:  {
        -: 1494:    //reduce number of cards in hand
    #####: 1495:    state->handCount[currentPlayer]--;
        -: 1496:  }
        -: 1497:  else
        -: 1498:  {
        -: 1499:    //replace discarded card with last card in hand
        6: 1500:    state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1501:    //set last card to -1
        6: 1502:    state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1503:    //reduce number of cards in hand
        6: 1504:    state->handCount[currentPlayer]--;
        -: 1505:  }
        -: 1506:
        6: 1507:  return 0;
        -: 1508:}
        -: 1509:
    #####: 1510:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1511:{
        -: 1512:  //Note: supplyPos is enum of choosen card
        -: 1513:
        -: 1514:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1515:  if (supplyCount(supplyPos, state) < 1)
        -: 1516:  {
    #####: 1517:    return -1;
        -: 1518:  }
        -: 1519:
        -: 1520:  //added card for [whoseTurn] current player:
        -: 1521:  // toFlag = 0 : add to discard
        -: 1522:  // toFlag = 1 : add to deck
        -: 1523:  // toFlag = 2 : add to hand
        -: 1524:
    #####: 1525:  if (toFlag == 1)
        -: 1526:  {
    #####: 1527:    state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1528:    state->deckCount[player]++;
        -: 1529:  }
    #####: 1530:  else if (toFlag == 2)
        -: 1531:  {
    #####: 1532:    state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1533:    state->handCount[player]++;
        -: 1534:  }
        -: 1535:  else
        -: 1536:  {
    #####: 1537:    state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1538:    state->discardCount[player]++;
        -: 1539:  }
        -: 1540:
        -: 1541:  //decrease number in supply pile
    #####: 1542:  state->supplyCount[supplyPos]--;
        -: 1543:
    #####: 1544:  return 0;
        -: 1545:}
        -: 1546:
        4: 1547:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1548:{
        -: 1549:  int i;
        -: 1550:
        -: 1551:  //reset coin count
        4: 1552:  state->coins = 0;
        -: 1553:
        -: 1554:  //add coins for each Treasure card in player's hand
       24: 1555:  for (i = 0; i < state->handCount[player]; i++)
        -: 1556:  {
       20: 1557:    if (state->hand[player][i] == copper)
        -: 1558:    {
       12: 1559:      state->coins += 1;
        -: 1560:    }
        8: 1561:    else if (state->hand[player][i] == silver)
        -: 1562:    {
    #####: 1563:      state->coins += 2;
        -: 1564:    }
        8: 1565:    else if (state->hand[player][i] == gold)
        -: 1566:    {
    #####: 1567:      state->coins += 3;
        -: 1568:    }
        -: 1569:  }
        -: 1570:
        -: 1571:  //add bonus
        4: 1572:  state->coins += bonus;
        -: 1573:
        4: 1574:  return 0;
        -: 1575:}
        -: 1576:
        -: 1577:
        -: 1578:
        -: 1579://end of dominion.c
